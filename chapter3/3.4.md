# 第四课：Reddit API和HTML5 Video
  
Giflist最有趣的地方是他里面没有一个GIF文件。GIF文件尺寸很大，加载很慢，虽然用户更在意他们的数据，但是这个也是个很大的问题。  
所以我们要做的是拉取GIF提供的**.webm**或者**.gifv**格式。这意味着我们不会展示GIF，我们将展示的是**video视频**。  
我们将使用HTML5的*<video>*标签来展示这些视频。始终记住，用HTML5来制作移动应用就可以使用HTML5的所有功能。非常典型的一个例子是**Geolocation** -- 我们可以使用本机【native】API来访问设备的GPS，但是在网页上我们也可以使用HTML5自带的Geolocation API。基本上，任何网页上可以做到的事情，移动应用上也可以做到（很明显，我们可以做到更多，因为我们可以访问本机功能）。  
在实现此功能之前，我们先来熟悉一下HTML5 Video。  

## HTML5 Video在iOS和Android上的行为
使用类似Ionic这样的框架意味着他们帮我们处理了平台之间的差异性，但是当制作跨平台应用的时候，还是会遇到一些平台差异性相关的问题。  
首先，对于*<video>*元素有一些需要的事情：
* 他可以全屏展示也可以嵌入使用
* 他有一个**poster**属性用于在视频加载之前作为封面展示
* 可以控制的视频的：控件是否展示，视频是否自动播放，是否嵌入页面播放

重点记住，*<video>*元素根据运行平台的不同，他的行为会有所不同。
* iOS上视频默认是全屏播放，但是也可以通过**webkit-playinline**属性来强制默认嵌入页面播放。同时，这也不是所有iOS设备通用的。在小的设备上，即使你指定了**webkit-playinline**属性，他还是会默认全屏播放（基本上，这个是没法解决的）。
* Android设备上默认是嵌入页面播放，但是可以设置默认全屏播放。

知道了这些不同，我们就需要找出如果解决这些问题。我们基本上有两个可选项：
1. 接受默认行为，不同平台使用相同的代码
2. 检查运行平台，运行不同代码来达到需求

个人而言，我更希望嵌入网页播放视频。但是由于在iOS小型设备上会默认全屏，我觉得还是用默认的行为好些。这意味着在iOS和Android上表现会有所不同，但是我觉得两者都很完美都可以接受，同时可以保持我们的代码简单整洁。  
好了，我们开始工作了。我们将实现**home.ts**里面的一些函数定义然后一个个的讲解。  
  
## 从Reddit获取数据
我们从最复杂最有趣的函数开始，同时也是整个应用最重要的核心功能：*fetchData()*。我们先添加代码然后讲解。  
**> 修改 src/app/providers/reddit.ts 的 fetchData 函数为如下：**
```typescript
fetchData(): void {
    //基于用户当前偏好组装URL来访问API
    let url = 'https://www.reddit.com/r/' + this.subreddit + '/' + this.sort + '/.json?limit='+ this.perPage;
    //如果我们不是在第一页的话，我们需要加上after参数才能得到新的结果
    //这个参数基本上就是讲"把 AFTER 这个帖子的帖子给我"
    if(this.after){
        url += '&after=' + this.after;
    }
    //我们现在拉取数据，所有要将loading变量设为 true
    this.loading = true;
    //向指定的URL发起请求然后订阅他的 response
    this.http.get(url).map(res => res.json()).subscribe(data => {
        let stopIndex = this.posts.length;
        this.posts = this.posts.concat(data.data.children);
        //循环所有的 NEW 帖子。
        //我们倒序循环的原因是因为需要移除一些项。
        for(let i = this.posts.length - 1; i >= stopIndex; i--){
            let post = this.posts[i];
            //添加一个新属性用于切换单个帖子的加载动画
            post.showLoader = false;
            post.alreadyLoaded = false;
            //给 NSFW 帖子添加 NSFW 印记
            if(post.data.thumbnail == 'nsfw'){
                this.posts[i].data.thumbnail = 'images/nsfw.png';
            }
            /*
            * 移除所有非 .gifv 或者 .webm 格式的帖子，然后将保留下来的帖子转换成.mp4文件
            * 
            */
            if(post.data.url.indexOf('.gifv') > -1 ||  post.data.url.indexOf('.webm') > -1){
                this.posts[i].data.url = post.data.url.replace('.gifv', '.mp4');
                this.posts[i].data.url = post.data.url.replace('.webm', '.mp4');
                //如果有缩略图的话，将他指定到 post 的 'snapshot'
                if(typeof(post.data.preview) != "undefined"){
                    this.posts[i].data.snapshot =  post.data.preview.images[0].source.url.replace(/&amp;/g, '&');
                    //如果 snapshot 未定义的话, 将他指定为空这样就不会显示一个破裂图
                    if(this.posts[i].data.snapshot == "undefined"){
                        this.posts[i].data.snapshot = "";
                    }
                }
                else {
                    this.posts[i].data.snapshot = "";
                }
            }
            else {
                this.posts.splice(i, 1);
            }
        }
        //如果没有得到够一页的数据那么继续获取GIF
        //但是，如果连续20次都没获取足够的数据的话就放弃
        if(data.data.children.length === 0 || this.moreCount > 20){
            this.moreCount = 0;
            this.loading = false;
        } else {
            this.after = data.data.children[data.data.children.length - 1].data.name;
            if(this.posts.length < this.perPage * this.page){
                this.fetchData();
                this.moreCount++;
            }
            else {
                this.loading = false;
                this.moreCount = 0;
            }
        }
    }, (err) => {
        //静默失败，此时加载旋转动画会持续显示
        console.log("subreddit doesn't exist!");
    });
}
```